var documenterSearchIndex = {"docs":
[{"location":"generated/man/rollouts/","page":"Rollouts","title":"Rollouts","text":"EditURL = \"../../../literate/man/rollouts.jl\"","category":"page"},{"location":"generated/man/rollouts/","page":"Rollouts","title":"Rollouts","text":"CollapsedDocStrings = true","category":"page"},{"location":"generated/man/rollouts/#Rollouts","page":"Rollouts","title":"Rollouts","text":"","category":"section"},{"location":"generated/man/rollouts/","page":"Rollouts","title":"Rollouts","text":"using QuantumCollocation\nusing SparseArrays # for visualization","category":"page"},{"location":"generated/man/rollouts/","page":"Rollouts","title":"Rollouts","text":"Rollouts are a way to visualize the evolution of a quantum system. The various rollout functions provided in this module allow for the validation of the solution to a quantum optimal control problem.","category":"page"},{"location":"generated/man/rollouts/","page":"Rollouts","title":"Rollouts","text":"","category":"page"},{"location":"generated/man/rollouts/","page":"Rollouts","title":"Rollouts","text":"This page was generated using Literate.jl.","category":"page"},{"location":"lib/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/#Problem-Templates","page":"Library","title":"Problem Templates","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.ProblemTemplates]","category":"page"},{"location":"lib/#QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","text":"QuantumStateMinimumTimeProblem(traj, sys, obj, integrators, constraints; kwargs...)\nQuantumStateMinimumTimeProblem(prob; kwargs...)\n\nConstruct a QuantumControlProblem for the minimum time problem of reaching a target state.\n\nArguments\n\ntraj::NamedTrajectory: The initial trajectory.\nsys::QuantumSystem: The quantum system.\nobj::Objective: The objective function.\nintegrators::Vector{<:AbstractIntegrator}: The integrators.\nconstraints::Vector{<:AbstractConstraint}: The constraints.\n\nor\n\nprob::QuantumControlProblem: The quantum control problem.\n\nKeyword Arguments\n\nstate_name::Symbol=:ψ̃: The symbol for the state variables.\nfinal_fidelity::Union{Real, Nothing}=nothing: The final fidelity.\nD=1.0: The cost weight on the time.\nipopt_options::IpoptOptions=IpoptOptions(): The Ipopt options.\npiccolo_options::PiccoloOptions=PiccoloOptions(): The Piccolo options.\nkwargs...: Additional keyword arguments, passed to QuantumControlProblem.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem","text":"QuantumStateSmoothPulseProblem(system, ψ_inits, ψ_goals, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(H_drift, H_drives, args...; kwargs...)\n\nCreate a quantum state smooth pulse problem. The goal is to find a control pulse a(t) that drives all of the initial states ψ_inits to the corresponding target states ψ_goals using T timesteps of size Δt. This problem also controls the first and second derivatives of the control pulse, da(t) and dda(t), to ensure smoothness.\n\nArguments\n\nsystem::AbstractQuantumSystem: The quantum system.\n\nor\n\nH_drift::AbstractMatrix{<:Number}: The drift Hamiltonian.\nH_drives::Vector{<:AbstractMatrix{<:Number}}: The control Hamiltonians.\n\nwith\n\nψ_inits::Vector{<:AbstractVector{<:ComplexF64}}: The initial states.\nψ_goals::Vector{<:AbstractVector{<:ComplexF64}}: The target states.\n\nor\n\nψ_init::AbstractVector{<:ComplexF64}: The initial state.\nψ_goal::AbstractVector{<:ComplexF64}: The target state.\n\nwith\n\nT::Int: The number of timesteps.\nΔt::Float64: The timestep size.\n\nKeyword Arguments\n\nipopt_options::IpoptOptions=IpoptOptions(): The IPOPT options.\npiccolo_options::PiccoloOptions=PiccoloOptions(): The Piccolo options.\nstate_name::Symbol=:ψ̃: The name of the state variable.\ncontrol_name::Symbol=:a: The name of the control variable.\ntimestep_name::Symbol=:Δt: The name of the timestep variable.\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: The initial trajectory.\na_bound::Float64=1.0: The bound on the control pulse.\na_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives)): The bounds on the control pulse.\na_guess::Union{Matrix{Float64}, Nothing}=nothing: The initial guess for the control pulse.\nda_bound::Float64=Inf: The bound on the first derivative of the control pulse.\nda_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives)): The bounds on the first derivative of the control pulse.\nzero_initial_and_final_derivative::Bool=false: Whether to enforce zero initial and final derivative.\ndda_bound::Float64=1.0: The bound on the second derivative of the control pulse.\ndda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives)): The bounds on the second derivative of the control pulse.\nΔt_min::Float64=0.5 * Δt: The minimum timestep size.\nΔt_max::Float64=1.5 * Δt: The maximum timestep size.\ndrive_derivative_σ::Float64=0.01: The standard deviation of the drive derivative random initialization.\nQ::Float64=100.0: The weight on the state objective.\nR=1e-2: The weight on the control pulse and its derivatives.\nR_a::Union{Float64, Vector{Float64}}=R: The weight on the control pulse.\nR_da::Union{Float64, Vector{Float64}}=R: The weight on the first derivative of the control pulse.\nR_dda::Union{Float64, Vector{Float64}}=R: The weight on the second derivative of the control pulse.\nleakage_operator::Union{Nothing, EmbeddedOperator}=nothing: The leakage operator, if leakage suppression is desired.\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: The constraints.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitaryBangBangProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryBangBangProblem","text":"UnitaryBangBangProblem(system::QuantumSystem, operator, T, Δt; kwargs...)\nUnitaryBangBangProblem(H_drift, H_drives, operator, T, Δt; kwargs...)\n\nConstruct a QuantumControlProblem for a free-time unitary gate problem with bang-bang control pulses.\n\nbeginaligned\nundersetvectildeU a dota Delta ttextminimize  quad\nQ cdot ellqty(vectildeU_T vectildeU_textgoal) + R_textbang-bang cdot sum_t dota_t \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n quad a_t+1 - a_t - dota_t Delta t_t = 0 \n quad a_t leq a_textbound \n quad dota_t leq da_textbound \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nwhere, for U in SU(N),\n\nellqty(vectildeU_T vectildeU_textgoal) =\nabs1 - frac1N abs tr qty(U_textgoal U_T) \n\nis the infidelity objective function, Q is a weight, R_a, and R_dota are weights on the regularization terms, and vbP^(n) is the nth-order Pade integrator.\n\nTODO: Document bang-bang modification.\n\nArguments\n\nH_drift::AbstractMatrix{<:Number}: the drift hamiltonian\nH_drives::Vector{<:AbstractMatrix{<:Number}}: the control hamiltonians\n\nor\n\nsystem::QuantumSystem: the system to be controlled\n\nwith\n\noperator::AbstractPiccoloOperator: the target unitary, either in the form of an EmbeddedOperator or a `Matrix{ComplexF64}\nT::Int: the number of timesteps\nΔt::Float64: the (initial) time step size\n\nKeyword Arguments\n\nipopt_options::IpoptOptions=IpoptOptions(): the options for the Ipopt solver\npiccolo_options::PiccoloOptions=PiccoloOptions(): the options for the Piccolo solver\nstate_name::Symbol = :Ũ⃗: the name of the state variable\ncontrol_name::Symbol = :a: the name of the control variable\ntimestep_name::Symbol = :Δt: the name of the timestep variable\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: an initial trajectory to use\na_bound::Float64=1.0: the bound on the control pulse\na_bounds=fill(a_bound, length(system.G_drives)): the bounds on the control pulses, one for each drive\na_guess::Union{Matrix{Float64}, Nothing}=nothing: an initial guess for the control pulses\nda_bound::Float64=1.0: the bound on the control pulse derivative\nda_bounds=fill(da_bound, length(system.G_drives)): the bounds on the control pulse derivatives, one for each drive\nΔt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt): the minimum time step size\nΔt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt): the maximum time step size\ndrive_derivative_σ::Float64=0.01: the standard deviation of the initial guess for the control pulse derivatives\nQ::Float64=100.0: the weight on the infidelity objective\nR=1e-2: the weight on the regularization terms\nquadratic_control_regularization=false: whether or not to use quadratic regularization for the control pulses\nR_a::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulses\nR_da::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse derivatives\nR_bang_bang::Union{Float64, Vector{Float64}}=1e-1: the weight on the bang-bang regularization term\nphase_operators::Union{AbstractVector{<:AbstractMatrix}, Nothing}=nothing: the phase operators for free phase corrections\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: the constraints to enforce\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitaryDirectSumProblem-Tuple{AbstractVector{<:QuantumControlProblem}, Real}","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryDirectSumProblem","text":"UnitaryDirectSumProblem(probs, final_fidelity; kwargs...)\n\nConstruct a QuantumControlProblem as a direct sum of unitary gate problems. The purpose is to find solutions that are as close as possible with respect to one of their components. In particular, this is useful for finding interpolatable control solutions.\n\nA graph of edges (specified by problem labels) will enforce a PairwiseQuadraticRegularizer between the component trajectories of the problem in probs corresponding to the names of the edge in edges with corresponding edge weight Q.\n\nBoundary values can be included to enforce a QuadraticRegularizer on edges where one of the nodes is not optimized. The boundary values are specified as a dictionary with keys corresponding to the edge labels and values corresponding to the boundary values.\n\nThe default behavior is to use a 1D chain for the graph, i.e., enforce a PairwiseQuadraticRegularizer between each neighbor of the provided probs.\n\nArguments\n\nprobs::AbstractVector{<:QuantumControlProblem}: the problems to combine\nfinal_fidelity::Real: the fidelity to enforce between the component final unitaries and the component goal unitaries\n\nKeyword Arguments\n\nprob_labels::AbstractVector{<:String}}: the labels for the problems\ngraph::Union{Nothing, AbstractVector{<:Tuple{String, String}}, AbstractVector{<:Tuple{Symbol, Symbol}}}`: the graph of edges to enforce\nboundary_values::Union{Nothing, AbstractDict{<:String, <:AbstractArray}, AbstractDict{<:Symbol, <:AbstractVector}}=nothing: the boundary values for the problems\nQ::Union{Float64, Vector{Float64}}=100.0: the weights on the pairwise regularizers\nQ_symb::Symbol=:Ũ⃗: the symbol to use for the regularizer\nR::Float64=1e-2: the shared weight on all control terms (:a, :da, :dda is assumed)\nR_a::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulses\nR_da::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse derivatives\nR_dda::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse second derivatives\nR_b::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the boundary values\ndrive_derivative_σ::Float64=0.01: the standard deviation of the initial guess for the control pulse derivatives\ndrive_reset_ratio::Float64=0.1: amount of random noise to add to the control data (can help avoid hitting restoration if provided problems are converged)\nfidelity_cost::Bool=false: whether or not to include a fidelity cost in the objective\nsubspace::Union{AbstractVector{<:Integer}, Nothing}=nothing: the subspace to use for the fidelity of each problem\nipopt_options::IpoptOptions=IpoptOptions(): the options for the Ipopt solver\npiccolo_options::PiccoloOptions=PiccoloOptions(): the options for the Piccolo solver\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","text":"UnitaryMinimumTimeProblem(\n    trajectory::NamedTrajectory,\n    system::AbstractQuantumSystem,\n    objective::Objective,\n    integrators::Vector{<:AbstractIntegrator},\n    constraints::Vector{<:AbstractConstraint};\n    kwargs...\n)\n\nUnitaryMinimumTimeProblem(\n    prob::QuantumControlProblem;\n    kwargs...\n)\n\nCreate a minimum-time problem for unitary control.\n\nbeginaligned\nundersetvectildeU a dota ddota Delta ttextminimize  quad\nJ(vectildeU a dota ddota) + D sum_t Delta t_t \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n c(vectildeU a dota ddota) = 0 \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nArguments\n\ntrajectory::NamedTrajectory: The initial trajectory.\nsystem::AbstractQuantumSystem: The quantum system.\nobjective::Objective: The objective function (additional to the minimum-time objective).\nintegrators::Vector{<:AbstractIntegrator}: The integrators.\nconstraints::Vector{<:AbstractConstraint}: The constraints.\n\nKeyword Arguments\n\nunitary_name::Symbol=:Ũ⃗: The symbol for the unitary control.\nfinal_fidelity::Float64=0.99: The final fidelity.\nD=1.0: The weight for the minimum-time objective.\nipopt_options::IpoptOptions=IpoptOptions(): The options for the Ipopt solver.\npiccolo_options::PiccoloOptions=PiccoloOptions(): The options for the Piccolo solver.\nkwargs...: Additional keyword arguments to pass to QuantumControlProblem.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitaryRobustnessProblem","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryRobustnessProblem","text":"UnitaryRobustnessProblem(\n    H_error,\n    trajectory,\n    system,\n    objective,\n    integrators,\n    constraints;\n    kwargs...\n)\n\nUnitaryRobustnessProblem(Hₑ, prob::QuantumControlProblem; kwargs...)\n\nCreate a quantum control problem for robustness optimization of a unitary trajectory.\n\nKeyword Arguments\n\nunitary_name::Symbol=:Ũ⃗: The symbol for the unitary trajectory in trajectory.\nfinal_fidelity::Union{Real, Nothing}=nothing: The target fidelity for the final unitary.\nipopt_options::IpoptOptions=IpoptOptions(): Options for the Ipopt solver.\npiccolo_options::PiccoloOptions=PiccoloOptions(): Options for the Piccolo solver.\nkwargs...: Additional keyword arguments passed to QuantumControlProblem.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-Tuple{AbstractVector{<:AbstractQuantumSystem}, AbstractVector{<:AbstractPiccoloOperator}, Int64, Union{Float64, Vector{Float64}}}","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitarySamplingProblem","text":"UnitarySamplingProblem(systemns, operator, T, Δt; kwargs...)\n\nA UnitarySamplingProblem is a quantum control problem where the goal is to find a control pulse that generates a target unitary operator for a set of quantum systems. The controls are shared among all systems, and the optimization seeks to find the control pulse that achieves the operator for each system. The idea is to enforce a robust solution by including multiple systems reflecting the problem uncertainty.\n\nArguments\n\nsystems::AbstractVector{<:AbstractQuantumSystem}: A vector of quantum systems.\noperator::AbstractPiccoloOperator: The target unitary operator.\nT::Int: The number of time steps.\nΔt::Union{Float64, Vector{Float64}}: The time step value or vector of time steps.\n\nKeyword Arguments\n\nsystem_labels::Vector{String} = string.(1:length(systems)): The labels for each system.\nsystem_weights::Vector{Float64} = fill(1.0, length(systems)): The weights for each system.\ninit_trajectory::Union{NamedTrajectory, Nothing} = nothing: The initial trajectory.\nipopt_options::IpoptOptions = IpoptOptions(): The IPOPT options.\npiccolo_options::PiccoloOptions = PiccoloOptions(): The Piccolo options.\nstate_name::Symbol = :Ũ⃗: The name of the state variable.\ncontrol_name::Symbol = :a: The name of the control variable.\ntimestep_name::Symbol = :Δt: The name of the timestep variable.\nconstraints::Vector{<:AbstractConstraint} = AbstractConstraint[]: The constraints.\na_bound::Float64 = 1.0: The bound for the control amplitudes.\na_bounds::Vector{Float64} = fill(a_bound, length(systems[1].G_drives)): The bounds for the control amplitudes.\na_guess::Union{Matrix{Float64}, Nothing} = nothing: The initial guess for the control amplitudes.\nda_bound::Float64 = Inf: The bound for the control first derivatives.\nda_bounds::Vector{Float64} = fill(da_bound, length(systems[1].G_drives)): The bounds for the control first derivatives.\ndda_bound::Float64 = 1.0: The bound for the control second derivatives.\ndda_bounds::Vector{Float64} = fill(dda_bound, length(systems[1].G_drives)): The bounds for the control second derivatives.\nΔt_min::Float64 = 0.5 * Δt: The minimum time step size.\nΔt_max::Float64 = 1.5 * Δt: The maximum time step size.\nQ::Float64 = 100.0: The fidelity weight.\nR::Float64 = 1e-2: The regularization weight.\nR_a::Union{Float64, Vector{Float64}} = R: The regularization weight for the control amplitudes.\nR_da::Union{Float64, Vector{Float64}} = R: The regularization weight for the control first derivatives.\nR_dda::Union{Float64, Vector{Float64}} = R: The regularization weight for the control second derivatives.\nkwargs...: Additional keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem-Tuple{AbstractQuantumSystem, AbstractPiccoloOperator, Int64, Union{Float64, AbstractVector{Float64}}}","page":"Library","title":"QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","text":"UnitarySmoothPulseProblem(system::AbstractQuantumSystem, operator, T, Δt; kwargs...)\nUnitarySmoothPulseProblem(H_drift, H_drives, operator, T, Δt; kwargs...)\n\nConstruct a QuantumControlProblem for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e.,\n\nbeginaligned\nundersetvectildeU a dota ddota Delta ttextminimize  quad\nQ cdot ellqty(vectildeU_T vectildeU_textgoal) + frac12 sum_t qty(R_a a_t^2 + R_dota dota_t^2 + R_ddota ddota_t^2) \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n quad a_t+1 - a_t - dota_t Delta t_t = 0 \n quad dota_t+1 - dota_t - ddota_t Delta t_t = 0 \n quad a_t leq a_textbound \n quad ddota_t leq ddota_textbound \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nwhere, for U in SU(N),\n\nellqty(vectildeU_T vectildeU_textgoal) =\nabs1 - frac1N abs tr qty(U_textgoal U_T) \n\nis the infidelity objective function, Q is a weight, R_a, R_dota, and R_ddota are weights on the regularization terms, and vbP^(n) is the nth-order Pade integrator.\n\nArguments\n\nsystem::AbstractQuantumSystem: the system to be controlled\n\nor\n\nH_drift::AbstractMatrix{<:Number}: the drift hamiltonian\nH_drives::Vector{<:AbstractMatrix{<:Number}}: the control hamiltonians\n\nwith\n\noperator::AbstractPiccoloOperator: the target unitary, either in the form of an EmbeddedOperator or a `Matrix{ComplexF64}\nT::Int: the number of timesteps\nΔt::Float64: the (initial) time step size\n\nKeyword Arguments\n\nipopt_options::IpoptOptions=IpoptOptions(): the options for the Ipopt solver\npiccolo_options::PiccoloOptions=PiccoloOptions(): the options for the Piccolo solver\nstate_name::Symbol = :Ũ⃗: the name of the state\ncontrol_name::Symbol = :a: the name of the control\ntimestep_name::Symbol = :Δt: the name of the timestep\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: an initial trajectory to use\na_bound::Float64=1.0: the bound on the control pulse\na_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives)): the bounds on the control pulses, one for each drive\na_guess::Union{Matrix{Float64}, Nothing}=nothing: an initial guess for the control pulses\nda_bound::Float64=Inf: the bound on the control pulse derivative\nda_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives)): the bounds on the control pulse derivatives, one for each drive\nzero_initial_and_final_derivative::Bool=false: whether to enforce zero initial and final control pulse derivatives\ndda_bound::Float64=1.0: the bound on the control pulse second derivative\ndda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives)): the bounds on the control pulse second derivatives, one for each drive\nΔt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt): the minimum time step size\nΔt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt): the maximum time step size\nQ::Float64=100.0: the weight on the infidelity objective\nR=1e-2: the weight on the regularization terms\nR_a::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulses\nR_da::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse derivatives\nR_dda::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse second derivatives\nphase_name::Symbol=:ϕ: the name of the phase\nphase_operators::Union{AbstractVector{<:AbstractMatrix}, Nothing}=nothing: the phase operators for free phase corrections\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: the constraints to enforce\n\n\n\n\n\n","category":"method"},{"location":"lib/#Options","page":"Library","title":"Options","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.Options]","category":"page"},{"location":"lib/#QuantumCollocationCore.Options.IpoptOptions","page":"Library","title":"QuantumCollocationCore.Options.IpoptOptions","text":"Solver options for Ipopt\n\nhttps://coin-or.github.io/Ipopt/OPTIONS.html#OPT_print_options_documentation\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocationCore.Options.PiccoloOptions","page":"Library","title":"QuantumCollocationCore.Options.PiccoloOptions","text":"PiccoloOptions\n\nOptions for the Piccolo quantum optimal control library.\n\nFields\n\nverbose::Bool = true: Print verbose output\nverbose_evaluator::Bool = false: Print verbose output from the evaluator\nfree_time::Bool = true: Allow free time optimization\ntimesteps_all_equal::Bool = true: Use equal timesteps\nintegrator::Symbol = :pade: Integrator to use\npade_order::Int = 4: Order of the Pade approximation\nrollout_integrator::Function = expv: Integrator to use for rollout\neval_hessian::Bool = false: Evaluate the Hessian\ngeodesic = true: Use the geodesic to initialize the optimization.\nblas_multithreading::Bool = true: Use BLAS multithreading.\nbuild_trajectory_constraints::Bool = true: Build trajectory constraints.\ncomplex_control_norm_constraint_name::Union{Nothing, Symbol} = nothing: Name of the complex control norm constraint.\ncomplex_control_norm_constraint_radius::Float64 = 1.0: Radius of the complex control norm constraint.\nbound_state::Bool = false: Bound the state.\nleakage_suppression::Bool = false: Suppress leakage.\nR_leakage::Float64 = 1.0: Leakage suppression parameter.\nfree_phase_infidelity::Bool = false: Free phase infidelity.\nphase_operators::Union{Nothing, AbstractVector{<:AbstractMatrix{<:Complex}}} = nothing: Phase operators.\nphase_name::Symbol = :ϕ: Name of the phase.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Rollouts","page":"Library","title":"Rollouts","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.Rollouts]","category":"page"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.infer_is_evp-Tuple{Function}","page":"Library","title":"PiccoloQuantumObjects.Rollouts.infer_is_evp","text":"infer_is_evp(integrator::Function)\n\nInfer whether the integrator is a exponential-vector product (EVP) function.\n\nIf true, the integrator is expected to have a signature like the exponential action, expv. Otherwise, it is expected to have a signature like exp.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.open_rollout-Tuple{AbstractMatrix{<:Complex}, AbstractMatrix, AbstractVector, AbstractQuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.Rollouts.open_rollout","text":"open_rollout(\n    ρ₁::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix,\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\n\nRollout a density matrix ρ₁ under the control controls and timesteps Δt\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.open_rollout-Tuple{AbstractVector{<:Real}, AbstractMatrix, AbstractVector, AbstractQuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.Rollouts.open_rollout","text":"open_rollout(\n    ρ⃗₁::AbstractVector{<:Complex},\n    controls::AbstractMatrix,\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\n\nRollout a quantum state ρ⃗₁ under the control controls for a time Δt\n\nArguments\n\nρ⃗₁::AbstractVector{<:Complex}: Initial state vector\ncontrols::AbstractMatrix: Control matrix\nΔt::AbstractVector: Time steps\nsystem::AbstractQuantumSystem: Quantum system\n\nKeyword Arguments\n\nshow_progress::Bool=false: Show progress bar\nintegrator::Function=expv: Integrator function\nexp_vector_product::Bool: Infer whether the integrator is an exponential-vector product\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.rollout-Tuple{AbstractVector{<:Real}, AbstractMatrix, AbstractVector, AbstractQuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.Rollouts.rollout","text":"rollout(\n    ψ̃_init::AbstractVector{<:Float64},\n    controls::AbstractMatrix,\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n)\n\nRollout a quantum state ψ̃_init under the control controls for a time Δt using the system system.\n\nIf exp_vector_product is true, the integrator is expected to have a signature like the exponential action, expv. Otherwise, it is expected to have a signature like exp.\n\nTypes should allow for autodifferentiable controls and times.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Direct-Sums","page":"Library","title":"Direct Sums","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.DirectSums]","category":"page"},{"location":"lib/#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{AbstractMatrix, AbstractMatrix}","page":"Library","title":"PiccoloQuantumObjects.DirectSums.direct_sum","text":"direct_sum(A::AbstractMatrix, B::AbstractMatrix)\n\nReturns the direct sum of two matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{AbstractVector, AbstractVector}","page":"Library","title":"PiccoloQuantumObjects.DirectSums.direct_sum","text":"direct_sum(Ã⃗::AbstractVector, B̃⃗::AbstractVector)\n\nReturns the direct sum of two iso_vec operators.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{QuantumSystem, QuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.DirectSums.direct_sum","text":"direct_sum(sys1::QuantumSystem, sys2::QuantumSystem)\n\nReturns the direct sum of two QuantumSystem objects.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}","page":"Library","title":"PiccoloQuantumObjects.DirectSums.direct_sum","text":"direct_sum(A::SparseMatrixCSC, B::SparseMatrixCSC)\n\nReturns the direct sum of two sparse matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Trajectory-Initialization","page":"Library","title":"Trajectory Initialization","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.TrajectoryInitialization]","category":"page"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{AbstractPiccoloOperator, Int64, Union{Real, AbstractVecOrMat{<:Real}}, Vararg{Any}}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","text":"initialize_trajectory\n\nTrajectory initialization of unitaries.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{AbstractVector{<:AbstractVector{ComplexF64}}, AbstractVector{<:AbstractVector{ComplexF64}}, Int64, Union{Real, AbstractVector{<:Real}}, Vararg{Any}}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","text":"initialize_trajectory\n\nTrajectory initialization of quantum states.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Any, Any, Int64, Union{Real, AbstractVecOrMat{<:Real}}, Vararg{Any}}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","text":"initialize_trajectory\n\nTrajectory initialization of density matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Vector{<:AbstractMatrix{Float64}}, Vector{<:AbstractVector{Float64}}, Vector{<:AbstractVector{Float64}}, AbstractVector{Symbol}, Int64, Union{Float64, AbstractVecOrMat{<:Float64}}, Int64, Tuple{Vararg{Union{Tuple{AbstractVector{R}, AbstractVector{R}}, AbstractVector{R}} where R<:Real}}}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","text":"initialize_trajectory\n\nInitialize a trajectory for a control problem. The trajectory is initialized with data that should be consistently the same type (in this case, Float64).\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.unitary_geodesic","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_geodesic","text":"unitary_geodesic(\n    operator::EmbeddedOperator,\n    samples::Int;\n    kwargs...\n)\n\nunitary_geodesic(\n    U_goal::AbstractMatrix{<:Number},\n    samples::Int;\n    kwargs...\n)\n\nunitary_geodesic(\n    U₀::AbstractMatrix{<:Number},\n    U₁::AbstractMatrix{<:Number},\n    samples::Number;\n    kwargs...\n)\n\nunitary_geodesic(\n    U₀::AbstractMatrix{<:Number},\n    U₁::AbstractMatrix{<:Number},\n    timesteps::AbstractVector{<:Number};\n    return_generator=false\n)\n\nCompute a geodesic connecting two unitary operators.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.unitary_geodesic-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, AbstractVector{<:Number}}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_geodesic","text":"unitary_geodesic(U_init, U_goal, times; kwargs...)\n\nCompute the geodesic connecting Uinit and Ugoal at the specified times. Allows for the possibility of unequal times and ranges outside [0,1].\n\nArguments\n\nU_init::AbstractMatrix{<:Number}: The initial unitary operator.\nU_goal::AbstractMatrix{<:Number}: The goal unitary operator.\ntimes::AbstractVector{<:Number}: The times at which to evaluate the geodesic.\n\nKeyword Arguments\n\nreturn_unitary_isos::Bool=true: If true returns a matrix where each column is a unitary isovec, i.e. vec(vcat(real(U), imag(U))). If false, returns a vector of unitary matrices.\nreturn_generator::Bool=false: If true, returns the effective Hamiltonian generating the geodesic.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Int64}","page":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation","text":"unitary_linear_interpolation(\n    U_init::AbstractMatrix,\n    U_goal::AbstractMatrix,\n    samples::Int\n)\n\nCompute a linear interpolation of unitary operators with samples samples.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Trajectory-Interpolations","page":"Library","title":"Trajectory Interpolations","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.TrajectoryInterpolations]","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"EditURL = \"../../../literate/man/ipopt_callbacks.jl\"","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"CollapsedDocStrings = true","category":"page"},{"location":"generated/man/ipopt_callbacks/#IpOpt-Callbacks","page":"Callbacks","title":"IpOpt Callbacks","text":"","category":"section"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"This page describes the callback functions that can be used with the IpOpt solver (in the future, may describe more general callback behavior).","category":"page"},{"location":"generated/man/ipopt_callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"using QuantumCollocation\nusing NamedTrajectories\n\nimport ..QuantumStateSmoothPulseProblem\nimport ..Callbacks","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"By default, IpOpt callbacks are called at each optimization step with the following signature:","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"function full_argument_list_callback(\n    alg_mod::Cint,\n    iter_count::Cint,\n    obj_value::Float64,\n    inf_pr::Float64,\n    inf_du::Float64,\n    mu::Float64,\n    d_norm::Float64,\n    regularization_size::Float64,\n    alpha_du::Float64,\n    alpha_pr::Float64,\n    ls_trials::Cint,\n)\n    return true\nend","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"This gives the user access to some of the optimization state internals at each iteration. A callback function with any subset of these arguments can be passed into the solve! function via the callback keyword argument see below.","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"The callback function can be used to stop the optimization early by returning false. The following callback when passed to solve! will stop the optimization after the first iteration:","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"my_callback = (kwargs...) -> false","category":"page"},{"location":"generated/man/ipopt_callbacks/#Single-initial-and-target-states","page":"Callbacks","title":"Single initial and target states","text":"","category":"section"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"T = 50\nΔt = 0.2\nsys = QuantumSystem(0.1 * GATES[:Z], [GATES[:X], GATES[:Y]])\nψ_init =  Vector{ComplexF64}([1.0, 0.0])\nψ_target =  Vector{ComplexF64}([0.0, 1.0])\n\nprob = QuantumStateSmoothPulseProblem(\n    sys, ψ_init, ψ_target, T, Δt;\n    ipopt_options=IpoptOptions(print_level=1),\n    piccolo_options=PiccoloOptions(verbose=false)\n)","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"The callback function can be used to monitor the optimization progress, save intermediate results, or modify the optimization process. For example, the following callback function saves the optimization trajectory at each iteration - this can be useful for debugging or plotting the optimization progress. trajectory_history_callback from the Callbacks module","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"callback, trajectory_history = QuantumCollocation.Callbacks.trajectory_history_callback(prob)\nsolve!(prob, max_iter=20, callback=callback)","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"Save trajectory images into files which can be used to create a gif like the following:","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"for (iter, traj) in enumerate(trajectory_history)\n    str_index = lpad(iter, length(string(length(trajectory_history))), \"0\")\n    plot(\"./iteration-$str_index-trajectory.png\", traj, [:ψ̃, :a], xlims=(-Δt, (T+5)*Δt), ylims=(ψ̃1 = (-2, 2), a = (-1.1, 1.1)))\nend","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"(Image: pulse optimization animation)","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"Using a callback to get the best trajectory from all the optimization iterations","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"sys2 = QuantumSystem(0.15 * GATES[:Z], [GATES[:X], GATES[:Y]])\nψ_init2 =  Vector{ComplexF64}([0.0, 1.0])\nψ_target2 =  Vector{ComplexF64}([1.0, 0.0])","category":"page"},{"location":"generated/man/ipopt_callbacks/#Using-other-callbacks-from-the-callback-library","page":"Callbacks","title":"Using other callbacks from the callback library","text":"","category":"section"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"Callback used here is best_rollout_fidelity_callback which appends the best trajectories based on monotonically increasing fidelity of the rollout","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"prob2 = QuantumStateSmoothPulseProblem(\n    sys2, ψ_init2, ψ_target2, T, Δt;\n    ipopt_options=IpoptOptions(print_level=1),\n    piccolo_options=PiccoloOptions(verbose=false)\n)\n\nbest_trajectory_callback, best_trajectory_list = best_rollout_fidelity_callback(prob2)\nsolve!(prob2, max_iter=20, callback=best_trajectory_callback)","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"fidelity of the last iterate","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"@show Losses.fidelity(prob2)","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"fidelity of the best iterate","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"@show QuantumCollocation.fidelity(best_trajectory_list[end], prob2.system)","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"","category":"page"},{"location":"generated/man/ipopt_callbacks/","page":"Callbacks","title":"Callbacks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div align=\"center\">\n  <a href=\"https://github.com/kestrelquantum/Piccolo.jl\">\n    <img src=\"assets/logo.svg\" alt=\"Piccolo.jl\" width=\"25%\"/>\n  </a>\n</div>\n\n<div align=\"center\">\n  <table>\n    <tr>\n      <td align=\"center\">\n        <b>Documentation</b>\n        <br>\n        <a href=\"https://kestrelquantum.github.io/QuantumCollocation.jl/stable/\">\n          <img src=\"https://img.shields.io/badge/docs-stable-blue.svg\" alt=\"Stable\"/>\n        </a>\n        <a href=\"https://kestrelquantum.github.io/QuantumCollocation.jl/dev/\">\n          <img src=\"https://img.shields.io/badge/docs-dev-blue.svg\" alt=\"Dev\"/>\n        </a>\n        <a href=\"https://arxiv.org/abs/2305.03261\">\n          <img src=\"https://img.shields.io/badge/arXiv-2305.03261-b31b1b.svg\" alt=\"arXiv\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>Build Status</b>\n        <br>\n        <a href=\"https://github.com/kestrelquantum/QuantumCollocation.jl/actions/workflows/CI.yml?query=branch%3Amain\">\n          <img src=\"https://github.com/kestrelquantum/QuantumCollocation.jl/actions/workflows/CI.yml/badge.svg?branch=main\" alt=\"Build Status\"/>\n        </a>\n        <a href=\"https://codecov.io/gh/kestrelquantum/QuantumCollocation.jl\">\n          <img src=\"https://codecov.io/gh/kestrelquantum/QuantumCollocation.jl/branch/main/graph/badge.svg\" alt=\"Coverage\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>License</b>\n        <br>\n        <a href=\"https://opensource.org/licenses/MIT\">\n          <img src=\"https://img.shields.io/badge/License-MIT-yellow.svg\" alt=\"MIT License\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>Support</b>\n        <br>\n        <a href=\"https://unitary.fund\">\n          <img src=\"https://img.shields.io/badge/Supported%20By-Unitary%20Fund-FFFF00.svg\" alt=\"Unitary Fund\"/>\n        </a>\n      </td>\n    </tr>\n  </table>\n</div>\n\n<div align=\"center\">\n  <i> Quickly set up and solve problem templates for quantum optimal control</i>\n  <br>\n</div>","category":"page"},{"location":"#QuantumCollocation.jl","page":"Home","title":"QuantumCollocation.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumCollocation.jl sets up and solves quantum control problems as nonlinear programs (NLPs). In this context, a generic quantum control problem looks like","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\n    arg min_mathbfZquad  J(mathbfZ) \n    nonumber textstqquad  mathbff(mathbfZ) = 0 \n    nonumber  mathbfg(mathbfZ) le 0  \nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where mathbfZ is a trajectory  containing states and controls, from NamedTrajectories.jl.","category":"page"},{"location":"#Problem-Templates","page":"Home","title":"Problem Templates","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Problem Templates are reusable design patterns for setting up and solving common quantum control problems. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, a UnitarySmoothPulseProblem is tasked with generating a pulse sequence a_1T-1 in orderd to minimize infidelity, subject to constraints from the Schroedinger equation,","category":"page"},{"location":"","page":"Home","title":"Home","text":"    beginaligned\n        arg min_mathbfZquad  1 - mathcalF(U_T U_textgoal)  \n        nonumber textst\n        qquad  U_t+1 = exp- i H(a_t) Delta t_t  U_t quad forall t \n    endaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"while a UnitaryMinimumTimeProblem minimizes time and constrains fidelity,","category":"page"},{"location":"","page":"Home","title":"Home","text":"    beginaligned\n        arg min_mathbfZquad  sum_t=1^T Delta t_t \n        qquad  U_t+1 = exp- i H(a_t) Delta t_t  U_t quad forall t \n        nonumber  mathcalF(U_T U_textgoal) ge 09999\n    endaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"In each case, the dynamics between knot points (U_t a_t) and (U_t+1 a_t+1) are enforced as constraints on the states, which are free variables in the solver; this optimization framework is called direct collocation. For details of our implementation please see our award-winning IEEE QCE 2023 paper, Direct Collocation for Quantum Optimal Control. If you use QuantumCollocation.jl in your work, please cite :raised_hands:!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Problem templates give the user the ability to add other constraints and objective functions to this problem and solve it efficiently using Ipopt.jl and MathOptInterface.jl under the hood.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is registered! To install, enter the Julia REPL, type ] to enter pkg mode, and then run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add QuantumCollocation","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"#Single-Qubit-Hadamard-Gate","page":"Home","title":"Single Qubit Hadamard Gate","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using QuantumCollocation\n\nT = 50\nΔt = 0.2\nsystem = QuantumSystem([PAULIS[:X], PAULIS[:Y]])\nU_goal = GATES.H\n\n# Hadamard Gate\nprob = UnitarySmoothPulseProblem(system, U_goal, T, Δt)\nsolve!(prob, max_iter=100)","category":"page"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"EditURL = \"../../../literate/man/problem_templates.jl\"","category":"page"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"CollapsedDocStrings = true","category":"page"},{"location":"generated/man/problem_templates/#Problem-Templates","page":"Problem Templates","title":"Problem Templates","text":"","category":"section"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"We provide a number of problem templates for making it simple and easy to set up and solve certain types of quantum optimal control problems. These templates all construct a QuantumControlProblem object.  The problem templates are:","category":"page"},{"location":"generated/man/problem_templates/#Unitary-Smooth-Pulse-Problem","page":"Problem Templates","title":"Unitary Smooth Pulse Problem","text":"","category":"section"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"UnitarySmoothPulseProblem","category":"page"},{"location":"generated/man/problem_templates/#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem-generated-man-problem_templates","page":"Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","text":"UnitarySmoothPulseProblem(system::AbstractQuantumSystem, operator, T, Δt; kwargs...)\nUnitarySmoothPulseProblem(H_drift, H_drives, operator, T, Δt; kwargs...)\n\nConstruct a QuantumControlProblem for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e.,\n\nbeginaligned\nundersetvectildeU a dota ddota Delta ttextminimize  quad\nQ cdot ellqty(vectildeU_T vectildeU_textgoal) + frac12 sum_t qty(R_a a_t^2 + R_dota dota_t^2 + R_ddota ddota_t^2) \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n quad a_t+1 - a_t - dota_t Delta t_t = 0 \n quad dota_t+1 - dota_t - ddota_t Delta t_t = 0 \n quad a_t leq a_textbound \n quad ddota_t leq ddota_textbound \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nwhere, for U in SU(N),\n\nellqty(vectildeU_T vectildeU_textgoal) =\nabs1 - frac1N abs tr qty(U_textgoal U_T) \n\nis the infidelity objective function, Q is a weight, R_a, R_dota, and R_ddota are weights on the regularization terms, and vbP^(n) is the nth-order Pade integrator.\n\nArguments\n\nsystem::AbstractQuantumSystem: the system to be controlled\n\nor\n\nH_drift::AbstractMatrix{<:Number}: the drift hamiltonian\nH_drives::Vector{<:AbstractMatrix{<:Number}}: the control hamiltonians\n\nwith\n\noperator::AbstractPiccoloOperator: the target unitary, either in the form of an EmbeddedOperator or a `Matrix{ComplexF64}\nT::Int: the number of timesteps\nΔt::Float64: the (initial) time step size\n\nKeyword Arguments\n\nipopt_options::IpoptOptions=IpoptOptions(): the options for the Ipopt solver\npiccolo_options::PiccoloOptions=PiccoloOptions(): the options for the Piccolo solver\nstate_name::Symbol = :Ũ⃗: the name of the state\ncontrol_name::Symbol = :a: the name of the control\ntimestep_name::Symbol = :Δt: the name of the timestep\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: an initial trajectory to use\na_bound::Float64=1.0: the bound on the control pulse\na_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives)): the bounds on the control pulses, one for each drive\na_guess::Union{Matrix{Float64}, Nothing}=nothing: an initial guess for the control pulses\nda_bound::Float64=Inf: the bound on the control pulse derivative\nda_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives)): the bounds on the control pulse derivatives, one for each drive\nzero_initial_and_final_derivative::Bool=false: whether to enforce zero initial and final control pulse derivatives\ndda_bound::Float64=1.0: the bound on the control pulse second derivative\ndda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives)): the bounds on the control pulse second derivatives, one for each drive\nΔt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt): the minimum time step size\nΔt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt): the maximum time step size\nQ::Float64=100.0: the weight on the infidelity objective\nR=1e-2: the weight on the regularization terms\nR_a::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulses\nR_da::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse derivatives\nR_dda::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse second derivatives\nphase_name::Symbol=:ϕ: the name of the phase\nphase_operators::Union{AbstractVector{<:AbstractMatrix}, Nothing}=nothing: the phase operators for free phase corrections\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: the constraints to enforce\n\n\n\n\n\n","category":"function"},{"location":"generated/man/problem_templates/#Unitary-Minimum-Time-Problem","page":"Problem Templates","title":"Unitary Minimum Time Problem","text":"","category":"section"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"UnitaryMinimumTimeProblem","category":"page"},{"location":"generated/man/problem_templates/#QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem-generated-man-problem_templates","page":"Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","text":"UnitaryMinimumTimeProblem(\n    trajectory::NamedTrajectory,\n    system::AbstractQuantumSystem,\n    objective::Objective,\n    integrators::Vector{<:AbstractIntegrator},\n    constraints::Vector{<:AbstractConstraint};\n    kwargs...\n)\n\nUnitaryMinimumTimeProblem(\n    prob::QuantumControlProblem;\n    kwargs...\n)\n\nCreate a minimum-time problem for unitary control.\n\nbeginaligned\nundersetvectildeU a dota ddota Delta ttextminimize  quad\nJ(vectildeU a dota ddota) + D sum_t Delta t_t \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n c(vectildeU a dota ddota) = 0 \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nArguments\n\ntrajectory::NamedTrajectory: The initial trajectory.\nsystem::AbstractQuantumSystem: The quantum system.\nobjective::Objective: The objective function (additional to the minimum-time objective).\nintegrators::Vector{<:AbstractIntegrator}: The integrators.\nconstraints::Vector{<:AbstractConstraint}: The constraints.\n\nKeyword Arguments\n\nunitary_name::Symbol=:Ũ⃗: The symbol for the unitary control.\nfinal_fidelity::Float64=0.99: The final fidelity.\nD=1.0: The weight for the minimum-time objective.\nipopt_options::IpoptOptions=IpoptOptions(): The options for the Ipopt solver.\npiccolo_options::PiccoloOptions=PiccoloOptions(): The options for the Piccolo solver.\nkwargs...: Additional keyword arguments to pass to QuantumControlProblem.\n\n\n\n\n\n","category":"function"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"","category":"page"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"This page was generated using Literate.jl.","category":"page"}]
}
